// This file was generated by Peginator v0.6.0 built at 1676279721
// CRC-32/ISO-HDLC of the grammar file: 8fff74eb
// Any changes to it will be lost on regeneration

#[derive(Debug, Clone)]
pub struct VkParser {
    pub statements: Vec<VkStatements>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum VkStatements {
    ClassStatement(ClassStatement),
    ControlFlowNode(ControlFlowNode),
    DefStatement(DefStatement),
    ExpressionNode(ExpressionNode),
    ForStatement(ForStatement),
    IfStatement(IfStatement),
    LetStatement(LetStatement),
    LoopStatement(LoopStatement),
    NamespaceDeclareNode(NamespaceDeclareNode),
    Semicolon(Semicolon),
    WhileStatement(WhileStatement),
}
#[derive(Debug, Clone)]
pub struct NamespaceDeclareNode {
    pub kw: KwNamespace,
    pub namespace: NamepathFree,
}
pub type KwNamespace = String;
#[derive(Debug, Clone)]
pub struct ClassStatement {
    pub namespace: Namepath,
    pub body: BlockNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct LoopStatement {
    pub body: BlockNode,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct WhileStatement {
    pub condition: ExpressionNode,
    pub body: BlockNode,
    pub r#else: Option<ElseStatement>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ForStatement {
    pub pattern: PatternNode,
    pub value: ExpressionNode,
    pub body: BlockNode,
    pub r#else: Option<ElseStatement>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct IfStatement {
    pub condition: ExpressionNode,
    pub body: BlockNode,
    pub r#else: Option<ElseStatement>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ElseIfStatement {
    pub condition: ExpressionNode,
    pub body: BlockNode,
    pub r#else: Option<ElseStatement>,
}
#[derive(Debug, Clone)]
pub struct ElseStatement {
    pub body: BlockNode,
}
#[derive(Debug, Clone)]
pub struct DefStatement {
    pub namespace: Namepath,
    pub parameters: Option<DefineArguments>,
    pub body: BlockNode,
}
#[derive(Debug, Clone)]
pub struct DefineArguments {
    pub args: Vec<DefineArgument>,
}
#[derive(Debug, Clone)]
pub struct DefineArgument {
    pub name: IdentifierNode,
    pub r#type: Option<TypeNode>,
    pub value: Option<ExpressionNode>,
}
#[derive(Debug, Clone)]
pub struct BlockNode {
    pub statements: Vec<VkStatements>,
}
#[derive(Debug, Clone)]
pub struct LetStatement {
    pub modifiers: Vec<Modifier>,
    pub pattern: PatternNode,
    pub r#type: Option<TypeNode>,
    pub value: Option<ExpressionNode>,
}
#[derive(Debug, Clone)]
pub struct PatternNode {
    pub name: IdentifierNode,
}
#[derive(Debug, Clone)]
pub struct TypeNode {
    pub id: IdentifierNode,
}
#[derive(Debug, Clone)]
pub struct ControlFlowNode {
    pub value: Option<ExpressionNode>,
}
#[derive(Debug, Clone)]
pub struct ExpressionNode {
    pub expr: Box<ExprNode>,
    pub infix: Vec<ExprInfix>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ExprInfix {
    pub infix: Infix,
    pub expr: ExprNode,
}
#[derive(Debug, Clone)]
pub struct ExprNode {
    pub prefix: Vec<Prefix>,
    pub term: TermNode,
    pub suffix: Vec<Suffix>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum TermNode {
    ExpressionNode(ExpressionNode),
    ListStatement(ListStatement),
    Namepath(Namepath),
    NumberNode(NumberNode),
    SpecialNode(SpecialNode),
    StringNode(StringNode),
    TableStatement(TableStatement),
    TupleStatement(TupleStatement),
}
#[derive(Debug, Clone)]
pub struct SpecialNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Prefix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Infix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Suffix {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type PrefixEx = String;
pub type BinaryEx = String;
pub type SuffixEx = String;
#[derive(Debug, Clone)]
pub struct TupleStatement {
    pub args: Vec<ExpressionNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ListStatement {
    pub args: Vec<ExpressionNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct TableStatement {
    pub args: Vec<KeyValueNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct LambdaStatement {
    pub parameters: Option<DefineArguments>,
}
#[derive(Debug, Clone)]
pub struct DotCall {
    pub name: IdentifierNode,
    pub args: Option<CallArguments>,
}
#[derive(Debug, Clone)]
pub struct CallArguments {
    pub args: Vec<CallArgument>,
}
#[derive(Debug, Clone)]
pub struct CallArgument {
    pub name: IdentifierNode,
    pub value: Option<ExpressionNode>,
}
#[derive(Debug, Clone)]
pub struct KeyValueNode {
    pub key: KeyNode,
    pub value: ValueNode,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum ValueNode {
    IntegerNode(IntegerNode),
    StringNode(StringNode),
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum KeyNode {
    IdentifierNode(IdentifierNode),
    IntegerNode(IntegerNode),
    StringNode(StringNode),
}
#[derive(Debug, Clone)]
pub struct StringNode {
    pub hint: Option<IdentifierNode>,
    pub raw: RawString,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct RawString {
    pub item: Vec<StringItem>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum StringItem {
    ESCAPE_C(ESCAPE_C),
    ESCAPE_U(ESCAPE_U),
    STRING_T(STRING_T),
    StringAny(StringAny),
}
#[derive(Debug, Clone)]
pub struct ESCAPE_C {
    pub char: StringAny,
}
#[derive(Debug, Clone)]
pub struct ESCAPE_U {
    pub hex: Vec<HEX>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct STRING_T {
    pub expr: ExpressionNode,
}
pub type StringAny = char;
#[derive(Debug, Clone)]
pub struct NumberNode {
    pub variant: NumberVariant,
    pub hint: Option<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[allow(non_camel_case_types)]
#[derive(Debug, Clone)]
pub enum NumberVariant {
    ByteBin(ByteBin),
    ByteHex(ByteHex),
    DecimalNode(DecimalNode),
    IntegerNode(IntegerNode),
}
#[derive(Debug, Clone)]
pub struct IntegerNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct DecimalNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ByteBin {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct ByteHex {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type HEX = char;
#[derive(Debug, Clone)]
pub struct NamespaceStar {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct Namepath {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NamepathFree {
    pub path: Vec<IdentifierNode>,
    pub position: std::ops::Range<usize>,
}
#[derive(Debug, Clone)]
pub struct NamespaceSplit;
#[derive(Debug, Clone)]
pub struct Modifier {
    pub id: IdentifierNode,
}
#[derive(Debug, Clone)]
pub struct IdentifierNode {
    pub string: String,
    pub position: std::ops::Range<usize>,
}
pub type XID_START = char;
pub type XID_CONTINUE = char;
pub type Dot = char;
#[derive(Debug, Clone)]
pub struct Semicolon;
pub type Split = char;
pub type Comment = String;
impl peginator_generated::PegParserAdvanced<()> for VkParser {
    fn parse_advanced<TT: peginator_generated::ParseTracer>(
        s: &str,
        settings: &peginator_generated::ParseSettings,
        user_defined: (),
    ) -> Result<Self, peginator_generated::ParseError> {
        Ok(peginator_generated::parse_VkParser(
            peginator_generated::ParseState::new(s, settings),
            &mut peginator_generated::ParseGlobal::<TT, peginator_generated::ParseCache, ()>::new(
                Default::default(),
                user_defined,
            ),
        )?
        .result)
    }
}
#[allow(non_snake_case, unused_variables, unused_imports, unused_mut, dead_code)]
mod peginator_generated {
    use super::*;
    use peginator::*;
    pub use peginator::{
        IndentedTracer, ParseError, ParseGlobal, ParseSettings, ParseState, ParseTracer, PegParser, PegParserAdvanced,
        PegPosition,
    };
    #[derive(Default)]
    pub struct ParseCache<'a> {
        _please_dont_complain: std::marker::PhantomData<&'a ()>,
    }
    mod VkParser_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<VkStatements> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_VkStatements(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<VkStatements>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut statements, state } = part_0::parse(state, global)?;
            let ParseOk { state, .. } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_end_of_input(state))?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<VkStatements>;
    }
    #[inline]
    pub(super) fn parse_VkParser<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, VkParser> {
        global.tracer.print_trace_start(&state, "VkParser");
        let result = {
            let result = VkParser_impl::parse(state, global)?.map(|r| super::VkParser { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod VkStatements_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceDeclareNode(state, global))
                        .map_inner(Parsed__override::NamespaceDeclareNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ClassStatement(state, global))
                        .map_inner(Parsed__override::ClassStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_DefStatement(state, global))
                        .map_inner(Parsed__override::DefStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_LetStatement(state, global))
                        .map_inner(Parsed__override::LetStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_LoopStatement(state, global))
                        .map_inner(Parsed__override::LoopStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_WhileStatement(state, global))
                        .map_inner(Parsed__override::WhileStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ForStatement(state, global))
                        .map_inner(Parsed__override::ForStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IfStatement(state, global))
                        .map_inner(Parsed__override::IfStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ControlFlowNode(state, global))
                        .map_inner(Parsed__override::ControlFlowNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, global))
                        .map_inner(Parsed__override::ExpressionNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Semicolon(state, global))
                        .map_inner(Parsed__override::Semicolon)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::VkStatements as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_VkStatements<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, VkStatements> {
        global.tracer.print_trace_start(&state, "VkStatements");
        let result = {
            let result = VkStatements_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod NamespaceDeclareNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: kw, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_KwNamespace(state, &mut *global))?;
            let ParseOk { result: namespace, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_NamepathFree(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { kw, namespace }, state })
        }
        pub struct Parsed {
            pub kw: KwNamespace,
            pub namespace: NamepathFree,
        }
    }
    #[inline]
    pub(super) fn parse_NamespaceDeclareNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceDeclareNode> {
        global.tracer.print_trace_start(&state, "NamespaceDeclareNode");
        let result = {
            let result = NamespaceDeclareNode_impl::parse(state, global)?
                .map(|r| super::NamespaceDeclareNode { kw: r.kw, namespace: r.namespace });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KwNamespace_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_string_literal(state, "namespace").discard_result()?;
            let ParseOk { state, .. } = ChoiceHelper::new(state.clone())
                .choice(|state| parse_character_literal(state, '!').discard_result())
                .choice(|state| parse_character_literal(state, '*').discard_result())
                .end()
                .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_KwNamespace<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KwNamespace> {
        global.tracer.print_trace_start(&state, "KwNamespace");
        let result = {
            let result = KwNamespace_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                string
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ClassStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "class"))
                .discard_result()?;
            let ParseOk { result: namespace, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Namepath(state, &mut *global))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { namespace, body }, state })
        }
        pub struct Parsed {
            pub namespace: Namepath,
            pub body: BlockNode,
        }
    }
    #[inline]
    pub(super) fn parse_ClassStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ClassStatement> {
        global.tracer.print_trace_start(&state, "ClassStatement");
        let result = {
            let result = ClassStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| {
                super::ClassStatement { namespace: r.namespace, body: r.body, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ClassStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod LoopStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "loop"))
                .discard_result()?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            Ok(ParseOk { result: body, state })
        }
        pub type Parsed = BlockNode;
    }
    #[inline]
    pub(super) fn parse_LoopStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, LoopStatement> {
        global.tracer.print_trace_start(&state, "LoopStatement");
        let result = {
            let result = LoopStatement_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::LoopStatement { body: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for LoopStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod WhileStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "while"))
                .discard_result()?;
            let ParseOk { result: condition, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            let ParseOk { result: r#else, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ElseStatement(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { condition, body, r#else }, state })
        }
        pub struct Parsed {
            pub condition: ExpressionNode,
            pub body: BlockNode,
            pub r#else: Option<ElseStatement>,
        }
    }
    #[inline]
    pub(super) fn parse_WhileStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, WhileStatement> {
        global.tracer.print_trace_start(&state, "WhileStatement");
        let result = {
            let result =
                WhileStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::WhileStatement {
                    condition: r.condition,
                    body: r.body,
                    r#else: r.r#else,
                    position: state.range_until(new_state),
                });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for WhileStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ForStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "for"))
                .discard_result()?;
            let ParseOk { result: pattern, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PatternNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "in"))
                .discard_result()?;
            let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            let ParseOk { result: r#else, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ElseStatement(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { pattern, value, body, r#else }, state })
        }
        pub struct Parsed {
            pub pattern: PatternNode,
            pub value: ExpressionNode,
            pub body: BlockNode,
            pub r#else: Option<ElseStatement>,
        }
    }
    #[inline]
    pub(super) fn parse_ForStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ForStatement> {
        global.tracer.print_trace_start(&state, "ForStatement");
        let result = {
            let result = ForStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::ForStatement {
                pattern: r.pattern,
                value: r.value,
                body: r.body,
                r#else: r.r#else,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ForStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod IfStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "if"))
                .discard_result()?;
            let ParseOk { result: condition, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            let ParseOk { result: r#else, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ElseStatement(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { condition, body, r#else }, state })
        }
        pub struct Parsed {
            pub condition: ExpressionNode,
            pub body: BlockNode,
            pub r#else: Option<ElseStatement>,
        }
    }
    #[inline]
    pub(super) fn parse_IfStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IfStatement> {
        global.tracer.print_trace_start(&state, "IfStatement");
        let result = {
            let result = IfStatement_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::IfStatement {
                condition: r.condition,
                body: r.body,
                r#else: r.r#else,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IfStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ElseIfStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "else"))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "if"))
                .discard_result()?;
            let ParseOk { result: condition, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            let ParseOk { result: r#else, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ElseStatement(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { condition, body, r#else }, state })
        }
        pub struct Parsed {
            pub condition: ExpressionNode,
            pub body: BlockNode,
            pub r#else: Option<ElseStatement>,
        }
    }
    #[inline]
    pub(super) fn parse_ElseIfStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ElseIfStatement> {
        global.tracer.print_trace_start(&state, "ElseIfStatement");
        let result = {
            let result = ElseIfStatement_impl::parse(state, global)?.map(|r| super::ElseIfStatement {
                condition: r.condition,
                body: r.body,
                r#else: r.r#else,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ElseStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "else"))
                .discard_result()?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            Ok(ParseOk { result: body, state })
        }
        pub type Parsed = BlockNode;
    }
    #[inline]
    pub(super) fn parse_ElseStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ElseStatement> {
        global.tracer.print_trace_start(&state, "ElseStatement");
        let result = {
            let result = ElseStatement_impl::parse(state, global)?.map(|r| super::ElseStatement { body: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "def"))
                .discard_result()?;
            let ParseOk { result: namespace, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Namepath(state, &mut *global))?;
            let ParseOk { result: parameters, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DefineArguments(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: body, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_BlockNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { namespace, parameters, body }, state })
        }
        pub struct Parsed {
            pub namespace: Namepath,
            pub parameters: Option<DefineArguments>,
            pub body: BlockNode,
        }
    }
    #[inline]
    pub(super) fn parse_DefStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefStatement> {
        global.tracer.print_trace_start(&state, "DefStatement");
        let result = {
            let result = DefStatement_impl::parse(state, global)?.map(|r| super::DefStatement {
                namespace: r.namespace,
                parameters: r.parameters,
                body: r.body,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefineArguments_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_DefineArgument(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<DefineArgument>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
                }
                pub type Parsed = Vec<DefineArgument>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_DefineArgument(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<DefineArgument>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<DefineArgument>;
    }
    #[inline]
    pub(super) fn parse_DefineArguments<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineArguments> {
        global.tracer.print_trace_start(&state, "DefineArguments");
        let result = {
            let result = DefineArguments_impl::parse(state, global)?.map(|r| super::DefineArguments { args: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DefineArgument_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()?;
                    let ParseOk { result: r#type, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_TypeNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: r#type, state })
                }
                pub type Parsed = Option<TypeNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<TypeNode>;
        }
        mod part_2 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: name, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { result: r#type, state } = part_1::parse(state, global)?;
            let ParseOk { result: value, state } = part_2::parse(state, global)?;
            Ok(ParseOk { result: Parsed { name, r#type, value }, state })
        }
        pub struct Parsed {
            pub name: IdentifierNode,
            pub r#type: Option<TypeNode>,
            pub value: Option<ExpressionNode>,
        }
    }
    #[inline]
    pub(super) fn parse_DefineArgument<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DefineArgument> {
        global.tracer.print_trace_start(&state, "DefineArgument");
        let result = {
            let result = DefineArgument_impl::parse(state, global)?.map(|r| super::DefineArgument {
                name: r.name,
                r#type: r.r#type,
                value: r.value,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod BlockNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut statements: Vec<VkStatements> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_VkStatements(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            statements.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: statements, state })
            }
            pub type Parsed = Vec<VkStatements>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut statements, state } = part_1::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: statements, state })
        }
        pub type Parsed = Vec<VkStatements>;
    }
    #[inline]
    pub(super) fn parse_BlockNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BlockNode> {
        global.tracer.print_trace_start(&state, "BlockNode");
        let result = {
            let result = BlockNode_impl::parse(state, global)?.map(|r| super::BlockNode { statements: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod LetStatement_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut modifiers: Vec<Modifier> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Modifier(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            modifiers.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: modifiers, state })
            }
            pub type Parsed = Vec<Modifier>;
        }
        mod part_3 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                        .discard_result()?;
                    let ParseOk { result: r#type, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_TypeNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: r#type, state })
                }
                pub type Parsed = Option<TypeNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<TypeNode>;
        }
        mod part_4 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "let"))
                .discard_result()?;
            let ParseOk { result: mut modifiers, state } = part_1::parse(state, global)?;
            let ParseOk { result: pattern, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PatternNode(state, &mut *global))?;
            let ParseOk { result: r#type, state } = part_3::parse(state, global)?;
            let ParseOk { result: value, state } = part_4::parse(state, global)?;
            Ok(ParseOk { result: Parsed { modifiers, pattern, r#type, value }, state })
        }
        pub struct Parsed {
            pub modifiers: Vec<Modifier>,
            pub pattern: PatternNode,
            pub r#type: Option<TypeNode>,
            pub value: Option<ExpressionNode>,
        }
    }
    #[inline]
    pub(super) fn parse_LetStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, LetStatement> {
        global.tracer.print_trace_start(&state, "LetStatement");
        let result = {
            let result = LetStatement_impl::parse(state, global)?.map(|r| super::LetStatement {
                modifiers: r.modifiers,
                pattern: r.pattern,
                r#type: r.r#type,
                value: r.value,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod PatternNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
        }
        pub type Parsed = IdentifierNode;
    }
    #[inline]
    pub(super) fn parse_PatternNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PatternNode> {
        global.tracer.print_trace_start(&state, "PatternNode");
        let result = {
            let result = PatternNode_impl::parse(state, global)?.map(|r| super::PatternNode { name: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod TypeNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
        }
        pub type Parsed = IdentifierNode;
    }
    #[inline]
    pub(super) fn parse_TypeNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TypeNode> {
        global.tracer.print_trace_start(&state, "TypeNode");
        let result = {
            let result = TypeNode_impl::parse(state, global)?.map(|r| super::TypeNode { id: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ControlFlowNode_impl {
        use super::*;
        mod choice_2 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "return"))
                    .discard_result()?;
                let ParseOk { result: value, state } = parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(Some)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
                Ok(ParseOk { result: value, state })
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        mod choice_3 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "raise"))
                    .discard_result()?;
                let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(Some)?;
                Ok(ParseOk { result: value, state })
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        mod choice_4 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "yield"))
                    .discard_result()?;
                let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(Some)?;
                Ok(ParseOk { result: value, state })
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        mod choice_5 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "yield"))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "from"))
                    .discard_result()?;
                let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(Some)?;
                Ok(ParseOk { result: value, state })
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        mod choice_6 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "yield"))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_string_literal(state, "break"))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "break"))
                        .discard_result()
                        .map_inner(|_| None)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "continue"))
                        .discard_result()
                        .map_inner(|_| None)
                })
                .choice(|state| choice_2::parse(state, global))
                .choice(|state| choice_3::parse(state, global))
                .choice(|state| choice_4::parse(state, global))
                .choice(|state| choice_5::parse(state, global))
                .choice(|state| choice_6::parse(state, global).map_inner(|_| None))
                .end()
        }
        pub type Parsed = Option<ExpressionNode>;
    }
    #[inline]
    pub(super) fn parse_ControlFlowNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ControlFlowNode> {
        global.tracer.print_trace_start(&state, "ControlFlowNode");
        let result = {
            let result = ControlFlowNode_impl::parse(state, global)?.map(|r| super::ControlFlowNode { value: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExpressionNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut infix: Vec<ExprInfix> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExprInfix(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            infix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: infix, state })
            }
            pub type Parsed = Vec<ExprInfix>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: expr, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExprNode(state, &mut *global))
                .map_inner(Box::new)?;
            let ParseOk { result: mut infix, state } = part_1::parse(state, global)?;
            Ok(ParseOk { result: Parsed { expr, infix }, state })
        }
        pub struct Parsed {
            pub expr: Box<ExprNode>,
            pub infix: Vec<ExprInfix>,
        }
    }
    #[inline]
    pub(super) fn parse_ExpressionNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExpressionNode> {
        global.tracer.print_trace_start(&state, "ExpressionNode");
        let result = {
            let result = ExpressionNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| {
                super::ExpressionNode { expr: r.expr, infix: r.infix, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ExpressionNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ExprInfix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: infix, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_Infix(state, &mut *global))?;
            let ParseOk { result: expr, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_ExprNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { infix, expr }, state })
        }
        pub struct Parsed {
            pub infix: Infix,
            pub expr: ExprNode,
        }
    }
    #[inline]
    pub(super) fn parse_ExprInfix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExprInfix> {
        global.tracer.print_trace_start(&state, "ExprInfix");
        let result = {
            let result = ExprInfix_impl::parse(state, global)?.map(|r| super::ExprInfix { infix: r.infix, expr: r.expr });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ExprNode_impl {
        use super::*;
        mod part_0 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut prefix: Vec<Prefix> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Prefix(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            prefix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: prefix, state })
            }
            pub type Parsed = Vec<Prefix>;
        }
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut suffix: Vec<Suffix> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Suffix(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            suffix.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: suffix, state })
            }
            pub type Parsed = Vec<Suffix>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut prefix, state } = part_0::parse(state, global)?;
            let ParseOk { result: term, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_TermNode(state, &mut *global))?;
            let ParseOk { result: mut suffix, state } = part_2::parse(state, global)?;
            Ok(ParseOk { result: Parsed { prefix, term, suffix }, state })
        }
        pub struct Parsed {
            pub prefix: Vec<Prefix>,
            pub term: TermNode,
            pub suffix: Vec<Suffix>,
        }
    }
    #[inline]
    pub(super) fn parse_ExprNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ExprNode> {
        global.tracer.print_trace_start(&state, "ExprNode");
        let result = {
            let result = ExprNode_impl::parse(state, global)?.map(|r| super::ExprNode {
                prefix: r.prefix,
                term: r.term,
                suffix: r.suffix,
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod TermNode_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { result: _override, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, global))
                    .map_inner(Parsed__override::ExpressionNode)?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: _override, state })
            }
            pub type Parsed = Parsed__override;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_TupleStatement(state, global))
                        .map_inner(Parsed__override::TupleStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_TableStatement(state, global))
                        .map_inner(Parsed__override::TableStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ListStatement(state, global))
                        .map_inner(Parsed__override::ListStatement)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_SpecialNode(state, global))
                        .map_inner(Parsed__override::SpecialNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_Namepath(state, global))
                        .map_inner(Parsed__override::Namepath)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NumberNode(state, global))
                        .map_inner(Parsed__override::NumberNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::TermNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_TermNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TermNode> {
        global.tracer.print_trace_start(&state, "TermNode");
        let result = {
            let result = TermNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod SpecialNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "null"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "default"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "true"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_string_literal(state, "false"))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, ''))
                        .discard_result()
                })
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_SpecialNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SpecialNode> {
        global.tracer.print_trace_start(&state, "SpecialNode");
        let result = {
            let result = SpecialNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                SpecialNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for SpecialNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Prefix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_PrefixEx(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Prefix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Prefix> {
        global.tracer.print_trace_start(&state, "Prefix");
        let result = {
            let result = Prefix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Prefix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Prefix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Infix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_BinaryEx(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Infix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Infix> {
        global.tracer.print_trace_start(&state, "Infix");
        let result = {
            let result = Infix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Infix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Infix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Suffix_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_SuffixEx(state, &mut *global))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Suffix<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Suffix> {
        global.tracer.print_trace_start(&state, "Suffix");
        let result = {
            let result = Suffix_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                Suffix { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Suffix {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_PrefixEx<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, PrefixEx> {
        match crate::utils::is_prefix(state.s()) {
            Ok((result, advance)) => Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) }),
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed { error_string })),
        }
    }
    #[inline]
    pub(super) fn parse_BinaryEx<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, BinaryEx> {
        match crate::utils::is_binary(state.s()) {
            Ok((result, advance)) => Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) }),
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed { error_string })),
        }
    }
    #[inline]
    pub(super) fn parse_SuffixEx<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, SuffixEx> {
        match crate::utils::is_suffix(state.s()) {
            Ok((result, advance)) => Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) }),
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed { error_string })),
        }
    }
    mod TupleStatement_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<ExpressionNode>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut args: Vec<ExpressionNode> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                args.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: args, state })
                }
                pub type Parsed = Vec<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                    .discard_result()
                    .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<ExpressionNode>;
    }
    #[inline]
    pub(super) fn parse_TupleStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TupleStatement> {
        global.tracer.print_trace_start(&state, "TupleStatement");
        let result = {
            let result = TupleStatement_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::TupleStatement { args: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for TupleStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ListStatement_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<ExpressionNode>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut args: Vec<ExpressionNode> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                args.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: args, state })
                }
                pub type Parsed = Vec<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                    .discard_result()
                    .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<ExpressionNode>;
    }
    #[inline]
    pub(super) fn parse_ListStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ListStatement> {
        global.tracer.print_trace_start(&state, "ListStatement");
        let result = {
            let result = ListStatement_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::ListStatement { args: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ListStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod TableStatement_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod closure {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_KeyValueNode(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<KeyValueNode>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut args: Vec<KeyValueNode> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                args.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: args, state })
                }
                pub type Parsed = Vec<KeyValueNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '['))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_KeyValueNode(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state.clone(), &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                    .discard_result()
                    .or_else(|err| Ok(ParseOk { result: (), state: state.record_error(err) }))?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ']'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<KeyValueNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<KeyValueNode>;
    }
    #[inline]
    pub(super) fn parse_TableStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, TableStatement> {
        global.tracer.print_trace_start(&state, "TableStatement");
        let result = {
            let result = TableStatement_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::TableStatement { args: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for TableStatement {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod LambdaStatement_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "lambda"))
                .discard_result()?;
            let ParseOk { result: parameters, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_DefineArguments(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: parameters, state })
        }
        pub type Parsed = Option<DefineArguments>;
    }
    #[inline]
    pub(super) fn parse_LambdaStatement<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, LambdaStatement> {
        global.tracer.print_trace_start(&state, "LambdaStatement");
        let result = {
            let result = LambdaStatement_impl::parse(state, global)?.map(|r| super::LambdaStatement { parameters: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod DotCall_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                .discard_result()?;
            let ParseOk { result: name, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { result: args, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_CallArguments(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { name, args }, state })
        }
        pub struct Parsed {
            pub name: IdentifierNode,
            pub args: Option<CallArguments>,
        }
    }
    #[inline]
    pub(super) fn parse_DotCall<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DotCall> {
        global.tracer.print_trace_start(&state, "DotCall");
        let result = {
            let result = DotCall_impl::parse(state, global)?.map(|r| super::DotCall { name: r.name, args: r.args });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CallArguments_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        mod choice_1 {
            use super::*;
            mod part_2 {
                use super::*;
                mod optional {
                    use super::*;
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_character_literal(state, ','))
                            .discard_result()?;
                        let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_CallArgument(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: args, state })
                    }
                    pub type Parsed = Vec<CallArgument>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    optional::parse(state.clone(), global)
                        .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
                }
                pub type Parsed = Vec<CallArgument>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                    .discard_result()?;
                let ParseOk { result: mut args, state } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_CallArgument(state, &mut *global))
                    .map_inner(|result| vec![result])?;
                let ParseOk { result: extend_args_with, state } = part_2::parse(state, global)?;
                args.extend(extend_args_with);
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, ')'))
                    .discard_result()?;
                Ok(ParseOk { result: args, state })
            }
            pub type Parsed = Vec<CallArgument>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global).map_inner(|_| Vec::new()))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<CallArgument>;
    }
    #[inline]
    pub(super) fn parse_CallArguments<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CallArguments> {
        global.tracer.print_trace_start(&state, "CallArguments");
        let result = {
            let result = CallArguments_impl::parse(state, global)?.map(|r| super::CallArguments { args: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod CallArgument_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod optional {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                        .discard_result()?;
                    let ParseOk { result: value, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))
                        .map_inner(Some)?;
                    Ok(ParseOk { result: value, state })
                }
                pub type Parsed = Option<ExpressionNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                optional::parse(state.clone(), global)
                    .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))
            }
            pub type Parsed = Option<ExpressionNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: name, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { result: value, state } = part_1::parse(state, global)?;
            Ok(ParseOk { result: Parsed { name, value }, state })
        }
        pub struct Parsed {
            pub name: IdentifierNode,
            pub value: Option<ExpressionNode>,
        }
    }
    #[inline]
    pub(super) fn parse_CallArgument<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, CallArgument> {
        global.tracer.print_trace_start(&state, "CallArgument");
        let result = {
            let result = CallArgument_impl::parse(state, global)?.map(|r| super::CallArgument { name: r.name, value: r.value });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KeyValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: key, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_KeyNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                .discard_result()?;
            let ParseOk { result: value, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_ValueNode(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { key, value }, state })
        }
        pub struct Parsed {
            pub key: KeyNode,
            pub value: ValueNode,
        }
    }
    #[inline]
    pub(super) fn parse_KeyValueNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KeyValueNode> {
        global.tracer.print_trace_start(&state, "KeyValueNode");
        let result = {
            let result = KeyValueNode_impl::parse(state, global)?.map(|r| super::KeyValueNode { key: r.key, value: r.value });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ValueNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IntegerNode(state, global))
                        .map_inner(Parsed__override::IntegerNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::ValueNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_ValueNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ValueNode> {
        global.tracer.print_trace_start(&state, "ValueNode");
        let result = {
            let result = ValueNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod KeyNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IntegerNode(state, global))
                        .map_inner(Parsed__override::IntegerNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, global))
                        .map_inner(Parsed__override::IdentifierNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringNode(state, global))
                        .map_inner(Parsed__override::StringNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::KeyNode as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_KeyNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, KeyNode> {
        global.tracer.print_trace_start(&state, "KeyNode");
        let result = {
            let result = KeyNode_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for KeyNode {
        fn position(&self) -> &std::ops::Range<usize> {
            match self {
                Self::IdentifierNode(x) => x.position(),
                Self::IntegerNode(x) => x.position(),
                Self::StringNode(x) => x.position(),
            }
        }
    }
    mod StringNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: hint, state } = parse_Whitespace(state.clone(), &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            let ParseOk { result: raw, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_RawString(state, &mut *global))?;
            Ok(ParseOk { result: Parsed { hint, raw }, state })
        }
        pub struct Parsed {
            pub hint: Option<IdentifierNode>,
            pub raw: RawString,
        }
    }
    #[inline]
    pub(super) fn parse_StringNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringNode> {
        global.tracer.print_trace_start(&state, "StringNode");
        let result = {
            let result = StringNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::StringNode {
                hint: r.hint,
                raw: r.raw,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for StringNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod RawString_impl {
        use super::*;
        mod choice_0 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                                    .discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut item, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_StringItem(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: item, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut item: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                item.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: item, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                    .discard_result()?;
                let ParseOk { result: mut item, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '"'))
                    .discard_result()?;
                Ok(ParseOk { result: item, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                    mod part_0 {
                        use super::*;
                        mod negative_lookahead {
                            use super::*;
                            #[inline(always)]
                            pub fn parse<'a, TT: ParseTracer>(
                                state: ParseState<'a>,
                                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                            ) -> ParseResult<'a, Parsed> {
                                parse_Whitespace(state, &mut *global)
                                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\''))
                                    .discard_result()
                            }
                            pub type Parsed = ();
                        }
                        #[inline(always)]
                        pub fn parse<'a, TT: ParseTracer>(
                            state: ParseState<'a>,
                            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                        ) -> ParseResult<'a, Parsed> {
                            match negative_lookahead::parse(state.clone(), global) {
                                Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                                Err(_) => Ok(ParseOk { result: (), state }),
                            }
                        }
                        pub type Parsed = ();
                    }
                    #[inline(always)]
                    pub fn parse<'a, TT: ParseTracer>(
                        state: ParseState<'a>,
                        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                    ) -> ParseResult<'a, Parsed> {
                        let ParseOk { state, .. } = part_0::parse(state, global)?;
                        let ParseOk { result: mut item, state } = parse_Whitespace(state, &mut *global)
                            .and_then(|ParseOk { state, .. }| parse_StringItem(state, &mut *global))
                            .map_inner(|result| vec![result])?;
                        Ok(ParseOk { result: item, state })
                    }
                    pub type Parsed = Vec<StringItem>;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    let mut item: Vec<StringItem> = Vec::new();
                    loop {
                        match closure::parse(state.clone(), global) {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                item.extend(__result);
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: item, state })
                }
                pub type Parsed = Vec<StringItem>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\''))
                    .discard_result()?;
                let ParseOk { result: mut item, state } = part_1::parse(state, global)?;
                let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                    .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\''))
                    .discard_result()?;
                Ok(ParseOk { result: item, state })
            }
            pub type Parsed = Vec<StringItem>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| choice_0::parse(state, global))
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = Vec<StringItem>;
    }
    #[inline]
    pub(super) fn parse_RawString<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, RawString> {
        global.tracer.print_trace_start(&state, "RawString");
        let result = {
            let result = RawString_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::RawString { item: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for RawString {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod StringItem_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ESCAPE_U(state, global))
                        .map_inner(Parsed__override::ESCAPE_U)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ESCAPE_C(state, global))
                        .map_inner(Parsed__override::ESCAPE_C)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_STRING_T(state, global))
                        .map_inner(Parsed__override::STRING_T)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_StringAny(state, global))
                        .map_inner(Parsed__override::StringAny)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::StringItem as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_StringItem<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringItem> {
        global.tracer.print_trace_start(&state, "StringItem");
        let result = {
            let result = StringItem_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ESCAPE_C_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { result: char, state } =
                parse_Whitespace(state, &mut *global).and_then(|ParseOk { state, .. }| parse_StringAny(state, &mut *global))?;
            Ok(ParseOk { result: char, state })
        }
        pub type Parsed = StringAny;
    }
    #[inline]
    pub(super) fn parse_ESCAPE_C<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ESCAPE_C> {
        global.tracer.print_trace_start(&state, "ESCAPE_C");
        let result = {
            let result = ESCAPE_C_impl::parse(state, global)?.map(|r| super::ESCAPE_C { char: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod ESCAPE_U_impl {
        use super::*;
        mod part_3 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut hex: Vec<HEX> = Vec::new();
                loop {
                    match parse_Whitespace(state.clone(), &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_HEX(state, &mut *global))
                        .map_inner(|result| vec![result])
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            hex.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: hex, state })
            }
            pub type Parsed = Vec<HEX>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '\\'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, 'u'))
                .discard_result()?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: mut hex, state } = part_3::parse(state, global)?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: hex, state })
        }
        pub type Parsed = Vec<HEX>;
    }
    #[inline]
    pub(super) fn parse_ESCAPE_U<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ESCAPE_U> {
        global.tracer.print_trace_start(&state, "ESCAPE_U");
        let result = {
            let result = ESCAPE_U_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::ESCAPE_U { hex: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ESCAPE_U {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod STRING_T_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '{'))
                .discard_result()?;
            let ParseOk { result: expr, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_ExpressionNode(state, &mut *global))?;
            let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '}'))
                .discard_result()?;
            Ok(ParseOk { result: expr, state })
        }
        pub type Parsed = ExpressionNode;
    }
    #[inline]
    pub(super) fn parse_STRING_T<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, STRING_T> {
        global.tracer.print_trace_start(&state, "STRING_T");
        let result = {
            let result = STRING_T_impl::parse(state, global)?.map(|r| super::STRING_T { expr: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    #[inline]
    pub(super) fn parse_StringAny<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, StringAny> {
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "StringAny" }))
    }
    mod NumberNode_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: variant, state } = parse_NumberVariant(state, &mut *global)?;
            let ParseOk { result: hint, state } = parse_IdentifierNode(state.clone(), &mut *global)
                .map_inner(Some)
                .or_else(|err| Ok(ParseOk { result: Default::default(), state: state.record_error(err) }))?;
            Ok(ParseOk { result: Parsed { variant, hint }, state })
        }
        pub struct Parsed {
            pub variant: NumberVariant,
            pub hint: Option<IdentifierNode>,
        }
    }
    #[inline]
    pub(super) fn parse_NumberNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NumberNode> {
        global.tracer.print_trace_start(&state, "NumberNode");
        let result = {
            let result = NumberNode_impl::parse(state.clone(), global)?.map_with_state(|r, new_state| super::NumberNode {
                variant: r.variant,
                hint: r.hint,
                position: state.range_until(new_state),
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NumberNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NumberVariant_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ByteBin(state, global))
                        .map_inner(Parsed__override::ByteBin)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_ByteHex(state, global))
                        .map_inner(Parsed__override::ByteHex)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_DecimalNode(state, global))
                        .map_inner(Parsed__override::DecimalNode)
                })
                .choice(|state| {
                    parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IntegerNode(state, global))
                        .map_inner(Parsed__override::IntegerNode)
                })
                .end()
        }
        pub type Parsed = Parsed__override;
        use super::NumberVariant as Parsed__override;
    }
    #[inline]
    pub(super) fn parse_NumberVariant<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NumberVariant> {
        global.tracer.print_trace_start(&state, "NumberVariant");
        let result = {
            let result = NumberVariant_impl::parse(state, global)?;
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod IntegerNode_impl {
        use super::*;
        mod choice_1 {
            use super::*;
            mod part_1 {
                use super::*;
                mod closure {
                    use super::*;
                }
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let mut iterations: usize = 0;
                    let mut state = state;
                    loop {
                        match ChoiceHelper::new(state.clone())
                            .choice(|state| parse_character_range(state, '0', '9').discard_result())
                            .choice(|state| parse_character_literal(state, '_').discard_result())
                            .end()
                        {
                            Ok(ParseOk { result: __result, state: new_state, .. }) => {
                                state = new_state;
                            }
                            Err(err) => {
                                state = state.record_error(err);
                                break;
                            }
                        }
                        iterations += 1;
                    }
                    Ok(ParseOk { result: (), state })
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let ParseOk { state, .. } = parse_character_range(state, '1', '9').discard_result()?;
                let ParseOk { state, .. } = part_1::parse(state, global)?;
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            ChoiceHelper::new(state)
                .choice(|state| parse_character_literal(state, '0').discard_result())
                .choice(|state| choice_1::parse(state, global))
                .end()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_IntegerNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IntegerNode> {
        global.tracer.print_trace_start(&state, "IntegerNode");
        let result = {
            let result = IntegerNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IntegerNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IntegerNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod DecimalNode_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match ChoiceHelper::new(state.clone())
                        .choice(|state| parse_character_range(state, '0', '9').discard_result())
                        .choice(|state| parse_character_literal(state, '_').discard_result())
                        .end()
                    {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_IntegerNode(state, &mut *global).discard_result()?;
            let ParseOk { state, .. } = parse_Dot(state, &mut *global).discard_result()?;
            let ParseOk { state, .. } = part_2::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_DecimalNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, DecimalNode> {
        global.tracer.print_trace_start(&state, "DecimalNode");
        let result = {
            let result = DecimalNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                DecimalNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for DecimalNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ByteBin_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_HEX(state.clone(), &mut *global).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '0').discard_result()?;
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_character_literal(state, 'b').discard_result())
                .choice(|state| parse_character_literal(state, 'B').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_2::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_ByteBin<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ByteBin> {
        global.tracer.print_trace_start(&state, "ByteBin");
        let result = {
            let result = ByteBin_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                ByteBin { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ByteBin {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod ByteHex_impl {
        use super::*;
        mod part_2 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_HEX(state.clone(), &mut *global).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                if iterations == 0 {
                    return Err(state.report_farthest_error());
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = parse_character_literal(state, '0').discard_result()?;
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_character_literal(state, 'x').discard_result())
                .choice(|state| parse_character_literal(state, 'X').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_2::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_ByteHex<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, ByteHex> {
        global.tracer.print_trace_start(&state, "ByteHex");
        let result = {
            let result = ByteHex_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                ByteHex { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for ByteHex {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_HEX<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, HEX> {
        if let Ok(result) = parse_character_range(state.clone(), '0', '9') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), 'a', 'f') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_range(state.clone(), 'A', 'F') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "HEX" }))
    }
    mod NamespaceStar_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceSplit(state, &mut *global))
                        .discard_result()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut path: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            path.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: path, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, global)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_NamespaceStar<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceStar> {
        global.tracer.print_trace_start(&state, "NamespaceStar");
        let result = {
            let result = NamespaceStar_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::NamespaceStar { path: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NamespaceStar {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod Namepath_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_NamespaceSplit(state, &mut *global))
                        .discard_result()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut path: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            path.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: path, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, global)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_Namepath<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Namepath> {
        global.tracer.print_trace_start(&state, "Namepath");
        let result = {
            let result = Namepath_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::Namepath { path: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for Namepath {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NamepathFree_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    let ParseOk { state, .. } = ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_NamespaceSplit(state, &mut *global))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_Dot(state, &mut *global))
                                .discard_result()
                        })
                        .end()?;
                    let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                        .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                        .map_inner(|result| vec![result])?;
                    Ok(ParseOk { result: path, state })
                }
                pub type Parsed = Vec<IdentifierNode>;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                let mut path: Vec<IdentifierNode> = Vec::new();
                loop {
                    match closure::parse(state.clone(), global) {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            path.extend(__result);
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: path, state })
            }
            pub type Parsed = Vec<IdentifierNode>;
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: mut path, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))
                .map_inner(|result| vec![result])?;
            let ParseOk { result: extend_path_with, state } = part_1::parse(state, global)?;
            path.extend(extend_path_with);
            Ok(ParseOk { result: path, state })
        }
        pub type Parsed = Vec<IdentifierNode>;
    }
    #[inline]
    pub(super) fn parse_NamepathFree<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamepathFree> {
        global.tracer.print_trace_start(&state, "NamepathFree");
        let result = {
            let result = NamepathFree_impl::parse(state.clone(), global)?
                .map_with_state(|r, new_state| super::NamepathFree { path: r, position: state.range_until(new_state) });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for NamepathFree {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    mod NamespaceSplit_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_string_literal(state, "::"))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_NamespaceSplit<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, NamespaceSplit> {
        global.tracer.print_trace_start(&state, "NamespaceSplit");
        let result = {
            let result = NamespaceSplit_impl::parse(state, global)?.map(|r| super::NamespaceSplit {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod Modifier_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod negative_lookahead {
                use super::*;
                #[inline(always)]
                pub fn parse<'a, TT: ParseTracer>(
                    state: ParseState<'a>,
                    global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
                ) -> ParseResult<'a, Parsed> {
                    ChoiceHelper::new(state)
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '('))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ':'))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '.'))
                                .discard_result()
                        })
                        .choice(|state| {
                            parse_Whitespace(state, &mut *global)
                                .and_then(|ParseOk { state, .. }| parse_character_literal(state, '='))
                                .discard_result()
                        })
                        .end()
                }
                pub type Parsed = ();
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                match negative_lookahead::parse(state.clone(), global) {
                    Ok(_) => Err(state.report_error(ParseErrorSpecifics::NegativeLookaheadFailed)),
                    Err(_) => Ok(ParseOk { result: (), state }),
                }
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { result: id, state } = parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_IdentifierNode(state, &mut *global))?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: id, state })
        }
        pub type Parsed = IdentifierNode;
    }
    #[inline]
    pub(super) fn parse_Modifier<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Modifier> {
        global.tracer.print_trace_start(&state, "Modifier");
        let result = {
            let result = Modifier_impl::parse(state, global)?.map(|r| super::Modifier { id: r });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    mod IdentifierNode_impl {
        use super::*;
        mod part_1 {
            use super::*;
            mod closure {
                use super::*;
            }
            #[inline(always)]
            pub fn parse<'a, TT: ParseTracer>(
                state: ParseState<'a>,
                global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
            ) -> ParseResult<'a, Parsed> {
                let mut iterations: usize = 0;
                let mut state = state;
                loop {
                    match parse_XID_CONTINUE(state.clone(), &mut *global).discard_result() {
                        Ok(ParseOk { result: __result, state: new_state, .. }) => {
                            state = new_state;
                        }
                        Err(err) => {
                            state = state.record_error(err);
                            break;
                        }
                    }
                    iterations += 1;
                }
                Ok(ParseOk { result: (), state })
            }
            pub type Parsed = ();
        }
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            let ParseOk { state, .. } = ChoiceHelper::new(state)
                .choice(|state| parse_XID_START(state, &mut *global).discard_result())
                .choice(|state| parse_character_literal(state, '_').discard_result())
                .end()?;
            let ParseOk { state, .. } = part_1::parse(state, global)?;
            Ok(ParseOk { result: (), state })
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_IdentifierNode<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, IdentifierNode> {
        global.tracer.print_trace_start(&state, "IdentifierNode");
        let result = {
            let result = IdentifierNode_impl::parse(state.clone(), global)?.map_with_state(|_, new_state| {
                let string = state.slice_until(new_state).to_string();
                IdentifierNode { string, position: state.range_until(new_state) }
            });
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    impl PegPosition for IdentifierNode {
        fn position(&self) -> &std::ops::Range<usize> {
            &self.position
        }
    }
    #[inline]
    pub(super) fn parse_XID_START<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_START> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_start(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_START" }))
    }
    #[inline]
    pub(super) fn parse_XID_CONTINUE<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, XID_CONTINUE> {
        if let Some(c) = state.s().chars().next() {
            if !unicode_ident::is_xid_continue(c) {
                return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
            }
        }
        else {
            return Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }));
        }
        if let Ok(result) = parse_char(state.clone(), global) {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "XID_CONTINUE" }))
    }
    #[inline]
    pub(super) fn parse_Dot<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Dot> {
        if let Ok(result) = parse_character_literal(state.clone(), '.') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Dot" }))
    }
    mod Semicolon_impl {
        use super::*;
        #[inline(always)]
        pub fn parse<'a, TT: ParseTracer>(
            state: ParseState<'a>,
            global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
        ) -> ParseResult<'a, Parsed> {
            parse_Whitespace(state, &mut *global)
                .and_then(|ParseOk { state, .. }| parse_character_literal(state, ';'))
                .discard_result()
        }
        pub type Parsed = ();
    }
    #[inline]
    pub(super) fn parse_Semicolon<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Semicolon> {
        global.tracer.print_trace_start(&state, "Semicolon");
        let result = {
            let result = Semicolon_impl::parse(state, global)?.map(|r| super::Semicolon {});
            Ok(result)
        };
        global.tracer.print_trace_result(&result);
        result
    }
    #[inline]
    pub(super) fn parse_Split<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Split> {
        if let Ok(result) = parse_character_literal(state.clone(), ';') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), ',') {
            return Ok(result);
        }
        if let Ok(result) = parse_character_literal(state.clone(), '') {
            return Ok(result);
        }
        Err(state.report_error(ParseErrorSpecifics::ExpectedCharacterClass { name: "Split" }))
    }
    #[inline]
    pub(super) fn parse_Comment<'a, TT: ParseTracer>(
        state: ParseState<'a>,
        global: &mut ParseGlobal<TT, ParseCache<'a>, ()>,
    ) -> ParseResult<'a, Comment> {
        match crate::utils::is_comment(state.s()) {
            Ok((result, advance)) => Ok(ParseOk { result: result.into(), state: state.advance_safe(advance) }),
            Err(error_string) => Err(state.report_error(ParseErrorSpecifics::ExternRuleFailed { error_string })),
        }
    }
}
