


class A {
	inherit Base;
	inherit Base2;
}


class B {
	item
}


@require {
	a: b
}
public static void fun main(args: [String], type A, ) {

}

union A(u8): A + B {
	A
}

def a() {

}

class A(B, C): C + D {
	pub static a(): Ref<B> + D {
		return 1
	}
	a {
		get {
			return 1
		}
		set {
			return 1
		}
	}

}


a::<T>()
a⦑T⦒
a<T>

base 1
a⟦T⟧
a⦃T⦄
a⟬T⟭
a⦅T⦆
base 0

a⦉T⦊

#? 能被 @derive 的 trait
@derive(Copy, Clone, Debug, PartialEq, Eq, Hash)
@(Copy, Clone , Debug, PartialEq, Eq, Hash)
derived macro A {

}


#? 隐式宏, 此类宏不需要
implicit macro print {

}

print("a")

a[T]
a⁅T⁆

@document.include("a/b")
/// a
/// a
@derive(Copy, Clone, Debug, PartialEq, Eq, Hash)
@(Copy, Clone , Debug, PartialEq, Eq, Hash)
class A⟬T <: Trait⟭ {
	@@where {
		T <: Trait
	}
	@@ensure {
		self > 0
	}

	a: T
}

extends<T> A<T> {

}